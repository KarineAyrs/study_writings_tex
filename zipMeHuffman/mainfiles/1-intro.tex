\section{Вспомогательные бибилиотеки}
Для корректной работы программы необходимы следующие пакеты:

\begin{lstlisting}[numbers=none]
collections
argparse
time
sys
pickle
\end{lstlisting}

Они содержатся в файле requirements.txt и при необходимости могут быть установлены с помощью следующей команды:
\begin{lstlisting}
    pip install -r /path/to/requirements.txt
\end{lstlisting}

\section{Использование программы: }

\begin{lstlisting}[numbers=none]
python3 huffman.py [-h] --r {1,2} --f FILENAME

Welcome to ZipMeHuffman!

optional arguments:
  -h, --help    show this help message and exit
  --r {1,2}     1 - compress, 2-decompress
  --f FILENAME  path to file to compress/decompress
\end{lstlisting}

Поддерживается два режима работы,  при этом выводится дополнительная информация: 
\begin{itemize}
    \item 1 - сжатие: 
    \begin{lstlisting}[numbers=none]
        python3 huffman.py --r 1 --f tocompress.txt   
        compressing file tocompress.txt...
        original size (bites):  794
        size after compress (raw, bites):  401
        time in seconds:  0.0027205944061279297
    \end{lstlisting}
    На выходе формируется файл с названием исходного файла и расширением .zmh
    \item 2 - разжатие:
    \begin{lstlisting}[numbers=none]
        python3 huffman.py --r 2 --f tocompress.zmh
        decompressing file tocompress.zmh...
        time in seconds:  0.0034983158111572266
    \end{lstlisting}
    На выходе формируется файл с названием исходного файла и добавкой \_dec в конце в формате исходного файла.
\end{itemize}

    

\section{Описание алгоритма}
Был реализован класс Huffman  с двумя основными методами: 
\begin{lstlisting}[numbers=none]
    Huffman.encode(self, enc_file_name)
    Huffman.decode(self, dec_file_name)
\end{lstlisting}
\subsection{Формат .zmh}
Структура файла формата .zmh следующая: 
\begin{enumerate}
    \item Длина закодированного сообщения
    \item Расширение файла до сжатия
    \item Длина словаря
    \item Словарь (pickle dumps)
\end{enumerate}

\subsection{Сжатие}
Файл с названием enc\_file\_name считывается в режиме rb, затем считается
частота встречания каждого байта и записывается в словарь, где ключ - байт, значение - частота (целое число).
Далее, создаются узлы с помощью вспомогательного класса Node и помещаются в список, где сортируются по убыванию частоты.
По алгоритму Хаффмана строится дерево: берутся два элемента с наименьшими частотами и \glqq склеиваются\grqq, новый элемент добавляется обратно в список, а два 
старых удаляются и становятся \glqq детьми\grqq\quad нового элемента. \par 
По полученному дереву строится таблица: движение происходит от корня дерева вниз, до листьев и собирается код. 
\par 
Затем производится кодирование: второй проход по входному файлу и замена байтов на соответствующие построенные коды. Полученная последовательность разбивается на куски по 8 бит и, 
так как последний байт может быть неполным, в выходной файл (формата .zmh) записывается длина закодированного сообщения для последующего корректного декодирования. Также записывается расширение исходного файла.
Для более компактной записи словаря используется модуль pickle, поэтому для дальнейшего декодирования записывается и длина словаря (после применения pickle.dumps). 
В самом конце записывается закодированное сообщение.
\subsection{Разжатие}
На вход подается файл с расширением .zmh. Далее, первой строкой считывается длина закодированного сообщения, вотрой строкой - расширение.
Затем последующие 4 байта отведены на длину словаря (len\_dic), с 4 по len\_dic считывается словарь, а остальное - закодированное сообщение.
\par 
При считывании кода байты преобразуются в двоичное представление и добиваются ведущими нулями до полных 8 бит, а последний байт обрабатывается отдельно - здесь количество 
нулей для добивки составляет:  \(code\_l - (code\_l // 8) * 8\), где code\_l - длина закодированного сообщения.\par

По считанному словарь восстанавливается дерево следующим образом: берется код (в данной реализации по порядку хранения в словаре) и посимвольно перебирается. Если стретился 0, 
то добавляется левый потомок (при отсутствии такового) и идет спуск к этому потомку. Аналогично и для 1, только здесь добавление и спуск к правому потомку. При просмотре следующего кода из словаря, 
обход дерева снова начинается с корня. \par 

Теперь, имея закодированное сообщение в двоичном виде и построенное дерево, производится раскодирование с помощью 
посимвольного прохода по сообщению и одновременно по дереву до листьев. На листьях расположены искомые закодированные символы. После достижения 
листьев просмотр возобновляется с корня. Раскодированное сообщение записывается в результирующий массив.
К имени файла добавляется окончание \_dec и расширение. 



\section{Анализ}
Время сжатия/разжатия указано в секундах. \par

\bigskip

\definecolor{Gray}{gray}{0.85}
\definecolor{LightCyan}{rgb}{0.88,1,1}

\newcolumntype{a}{>{\columncolor{Gray}}c}
\newcolumntype{g}{>{\columncolor{LightCyan}}c}
% \definecolor{lightRed}{RGB}{230,170,150}


{\small
\begin{tabular}{|c|g|a|c|c|a|c|c|a|c|c|}
    \hline
    % \rowcolor{LightCyan}
    Файл & Исх. & \multicolumn{3}{|c|}{ZipMeHuffman} & \multicolumn{3}{|c|} {ZIP} & \multicolumn{3}{|c|}{7z}\\
    \cline{3-11}

    &  р-р   &р-р  & вр. &вр.   &р-р  & вр. &вр. &р-р  & вр. &вр. \\ 
    
    &        & сж. & сж. & раз. & сж. & сж. & раз. & сж. & сж. & раз.\\
    \hline
    txt  &76,9kB  &40,2kB &  0.07 & 0.11 &21,9kB &  0.035 & 0.015 & 19,4kB&0.015& 0.014\\ \cline{3-11}
    \hline
    
    txt&333,3kB  &172,9kB  &0.11 &0.26 &97,2kB &0.12  &0.022&80,2kB&0.15&0.027\\ \cline{3-11}
    
    \hline
    
    pdf & 5,4MB &5,4MB &2.04& 16.02& 5,3MB &0.27&0.15 &5,2MB & 0.6&0.29\\ \cline{3-11}
    \hline
    pdf & 81,1kB & 84,4kB * & 0.1&0.14 & 78,6kB & 0.013 & 0.007 &79,0kB&0.028 &0.028\\ \cline{3-11}
    \hline 
    csv & 486,3kB & 231,1kB &0.15&0.34&222,3kB&0.14&0.021 &181,3kB&0.19&0.055\\ \cline{3-11}
    \hline
    csv & 1,5MB& 852,4kB &0.4&1.2& 723,5kB&0.13&0.04&638,5kB&0.24&0.057\\ \cline{3-11}
    \hline
    jpg & 6,3MB&6,3MB&2.6&19.4&6,3MB&0.32&0.16 &6,2MB&0.7& 0.4 \\ \cline{3-11}
    \hline 
    png &12,9kB & 16,3kB* & 0.04&0.01&12,9kB&0.005&0.002&12,9kB&0.018& 0.012\\ \cline{3-11}
    \hline \hline
    \end{tabular}
}


\bigskip

ZMH сжимает текстовые данные ~ в 2 раза с учетом накладных расходов, в то время как ZIP и 7z сжимают ~
в 4 раза и делают это быстрее, чем ZMH (предположение: в ZIP и 7z уже встроена и используется таблица с оптимальными кодами для часто встречающихся алфавитов?). В случае с pdf файлами у ZMH сжатия не происходит либо доваляются накладные расходы (*- Было 81,1kB, стало 84,4kB, но до сжатия pdf файл имел размер 
81100 бит, после чистый размер без словаря и т.д. составил 81033. Таким образом, из-за накладных расходов размер файла увеличился). 
CSV-файлы сжимаются в ~2 раза с помощью  ZMH и с чуть лучшим успехом у ZIP и 7z. \par 
JPEG, PNG - файлы не сжимаются (так как JPEG и PNG итак сжаты в первом случае одноименным алгоритмом сжатия, а во втором - 
алгоритмом deflate-сжатия, который является улучшенной версией алгоритма сжатия Lempel-Ziv (LZ77), который используется в ZIP- и 
GZIP-файлах),снова размер файла может увеличиться из-за накладных расходов. (* - png было 12917 бит, стало 12906 \glqq чистых\grqq\quad бит).

\subsection*{Вывод}

Данная реализация ZMH сжимает данные, но работает хуже и намного медленнее (декодирование) существующих решений (здесь декодирование осуществляется проходом по закодированному сообщению и дереву, а в ZIP, например,
происходит декодирование на основе поисковой таблицы,что быстрее). Также, накладные расходы нужно записывать еще компактнее, чем реализовано мной (с помощью pickle).

